---
alwaysApply: false
globs:
  - armature-graphql/**
  - armature-graphql-client/**
---

# GraphQL Development

Guidelines for GraphQL API development with Armature.

## GraphQL Crates

| Crate | Purpose |
|-------|---------|
| `armature-graphql` | GraphQL server with async-graphql |
| `armature-graphql-client` | GraphQL client for external APIs |

## Schema Definition

### Types and Objects

```rust
use async_graphql::*;

/// A user in the system.
#[derive(SimpleObject)]
pub struct User {
    /// Unique identifier
    pub id: ID,

    /// User's email address
    pub email: String,

    /// Display name
    pub name: String,

    /// Account creation timestamp
    pub created_at: DateTime<Utc>,
}

/// Extended user type with relations
#[derive(Default)]
pub struct UserType {
    pub user: User,
}

#[Object]
impl UserType {
    async fn id(&self) -> &ID {
        &self.user.id
    }

    async fn email(&self) -> &str {
        &self.user.email
    }

    async fn name(&self) -> &str {
        &self.user.name
    }

    /// User's posts (resolved lazily)
    async fn posts(&self, ctx: &Context<'_>) -> Result<Vec<Post>> {
        let loader = ctx.data::<DataLoader<PostLoader>>()?;
        let posts = loader.load_one(self.user.id.parse()?).await?;
        Ok(posts.unwrap_or_default())
    }

    /// User's role
    async fn role(&self, ctx: &Context<'_>) -> Result<Role> {
        let service = ctx.data::<RoleService>()?;
        service.get_user_role(self.user.id.parse()?).await
    }
}
```

### Input Types

```rust
/// Input for creating a new user.
#[derive(InputObject)]
pub struct CreateUserInput {
    /// User's email (must be unique)
    #[graphql(validator(email))]
    pub email: String,

    /// User's password (min 8 characters)
    #[graphql(validator(min_length = 8))]
    pub password: String,

    /// Display name
    #[graphql(validator(min_length = 1, max_length = 100))]
    pub name: String,
}

/// Input for updating a user.
#[derive(InputObject)]
pub struct UpdateUserInput {
    /// New email address
    #[graphql(validator(email))]
    pub email: Option<String>,

    /// New display name
    #[graphql(validator(min_length = 1, max_length = 100))]
    pub name: Option<String>,
}

/// Filter options for listing users.
#[derive(InputObject, Default)]
pub struct UserFilter {
    /// Filter by name (contains)
    pub name: Option<String>,

    /// Filter by role
    pub role: Option<Role>,

    /// Filter by creation date (after)
    pub created_after: Option<DateTime<Utc>>,
}
```

### Enums

```rust
/// User role in the system.
#[derive(Enum, Copy, Clone, Eq, PartialEq)]
pub enum Role {
    /// Regular user
    User,
    /// Moderator with elevated privileges
    Moderator,
    /// Administrator with full access
    Admin,
}

/// Sort direction.
#[derive(Enum, Copy, Clone, Eq, PartialEq, Default)]
pub enum SortDirection {
    #[default]
    Asc,
    Desc,
}
```

## Query Implementation

```rust
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    /// Get the currently authenticated user.
    async fn me(&self, ctx: &Context<'_>) -> Result<Option<User>> {
        let user = ctx.data_opt::<AuthenticatedUser>();
        match user {
            Some(auth) => {
                let service = ctx.data::<UserService>()?;
                service.find_by_id(auth.user_id).await
            }
            None => Ok(None),
        }
    }

    /// Get a user by ID.
    async fn user(&self, ctx: &Context<'_>, id: ID) -> Result<Option<User>> {
        let service = ctx.data::<UserService>()?;
        service.find_by_id(id.parse()?).await
    }

    /// List users with optional filtering and pagination.
    async fn users(
        &self,
        ctx: &Context<'_>,
        #[graphql(default)] filter: UserFilter,
        #[graphql(default = 1)] page: u32,
        #[graphql(default = 20, validator(maximum = 100))] per_page: u32,
    ) -> Result<UserConnection> {
        let service = ctx.data::<UserService>()?;
        let (users, total) = service.list(filter, page, per_page).await?;

        Ok(UserConnection {
            nodes: users,
            page_info: PageInfo {
                page,
                per_page,
                total,
                has_next_page: (page * per_page) < total as u32,
                has_previous_page: page > 1,
            },
        })
    }

    /// Search users by name or email.
    async fn search_users(
        &self,
        ctx: &Context<'_>,
        query: String,
        #[graphql(default = 10, validator(maximum = 50))] limit: u32,
    ) -> Result<Vec<User>> {
        let service = ctx.data::<UserService>()?;
        service.search(&query, limit).await
    }
}
```

## Mutation Implementation

```rust
pub struct MutationRoot;

#[Object]
impl MutationRoot {
    /// Create a new user account.
    async fn create_user(
        &self,
        ctx: &Context<'_>,
        input: CreateUserInput,
    ) -> Result<User> {
        let service = ctx.data::<UserService>()?;

        // Check for existing email
        if service.email_exists(&input.email).await? {
            return Err(Error::new("Email already registered"));
        }

        service.create(input).await
    }

    /// Update the current user's profile.
    #[graphql(guard = "AuthGuard")]
    async fn update_profile(
        &self,
        ctx: &Context<'_>,
        input: UpdateUserInput,
    ) -> Result<User> {
        let auth = ctx.data::<AuthenticatedUser>()?;
        let service = ctx.data::<UserService>()?;

        service.update(auth.user_id, input).await
    }

    /// Delete a user (admin only).
    #[graphql(guard = "RoleGuard::new(Role::Admin)")]
    async fn delete_user(
        &self,
        ctx: &Context<'_>,
        id: ID,
    ) -> Result<bool> {
        let service = ctx.data::<UserService>()?;
        service.delete(id.parse()?).await?;
        Ok(true)
    }

    /// Authenticate and get tokens.
    async fn login(
        &self,
        ctx: &Context<'_>,
        email: String,
        password: String,
    ) -> Result<AuthPayload> {
        let auth_service = ctx.data::<AuthService>()?;
        auth_service.authenticate(&email, &password).await
    }
}
```

## Subscription Implementation

```rust
pub struct SubscriptionRoot;

#[Subscription]
impl SubscriptionRoot {
    /// Subscribe to new messages in a chat room.
    async fn messages(
        &self,
        ctx: &Context<'_>,
        room_id: ID,
    ) -> impl Stream<Item = Message> {
        let broadcaster = ctx.data_unchecked::<MessageBroadcaster>();
        let room_id: i64 = room_id.parse().unwrap();

        broadcaster.subscribe(room_id)
    }

    /// Subscribe to user presence updates.
    async fn user_presence(
        &self,
        ctx: &Context<'_>,
    ) -> impl Stream<Item = PresenceUpdate> {
        let presence = ctx.data_unchecked::<PresenceService>();
        presence.subscribe()
    }

    /// Subscribe to notifications for the current user.
    #[graphql(guard = "AuthGuard")]
    async fn notifications(
        &self,
        ctx: &Context<'_>,
    ) -> Result<impl Stream<Item = Notification>> {
        let auth = ctx.data::<AuthenticatedUser>()?;
        let notifications = ctx.data::<NotificationService>()?;

        Ok(notifications.subscribe(auth.user_id))
    }
}
```

## Data Loaders (N+1 Prevention)

```rust
use async_graphql::dataloader::*;

pub struct PostLoader {
    pool: PgPool,
}

impl Loader<i64> for PostLoader {
    type Value = Vec<Post>;
    type Error = Error;

    async fn load(&self, keys: &[i64]) -> Result<HashMap<i64, Self::Value>, Self::Error> {
        let posts = sqlx::query_as!(
            Post,
            r#"SELECT * FROM posts WHERE user_id = ANY($1)"#,
            keys
        )
        .fetch_all(&self.pool)
        .await?;

        // Group posts by user_id
        let mut map: HashMap<i64, Vec<Post>> = HashMap::new();
        for post in posts {
            map.entry(post.user_id).or_default().push(post);
        }

        Ok(map)
    }
}

// Register in schema
let schema = Schema::build(QueryRoot, MutationRoot, SubscriptionRoot)
    .data(DataLoader::new(PostLoader { pool: pool.clone() }, tokio::spawn))
    .finish();
```

## Guards for Authorization

```rust
use async_graphql::*;

/// Guard that requires authentication.
pub struct AuthGuard;

#[async_trait::async_trait]
impl Guard for AuthGuard {
    async fn check(&self, ctx: &Context<'_>) -> Result<()> {
        if ctx.data_opt::<AuthenticatedUser>().is_some() {
            Ok(())
        } else {
            Err("Unauthorized".into())
        }
    }
}

/// Guard that requires a specific role.
pub struct RoleGuard {
    required_role: Role,
}

impl RoleGuard {
    pub fn new(role: Role) -> Self {
        Self { required_role: role }
    }
}

#[async_trait::async_trait]
impl Guard for RoleGuard {
    async fn check(&self, ctx: &Context<'_>) -> Result<()> {
        let auth = ctx.data_opt::<AuthenticatedUser>()
            .ok_or("Unauthorized")?;

        if auth.role >= self.required_role {
            Ok(())
        } else {
            Err("Forbidden".into())
        }
    }
}
```

## Schema Integration with Armature

```rust
use armature::prelude::*;
use armature_graphql::*;

#[module(
    providers: [
        GraphQLSchemaProvider,
        UserService,
        PostService,
        AuthService,
    ],
    controllers: [GraphQLController],
)]
pub struct GraphQLModule;

#[injectable]
pub struct GraphQLSchemaProvider {
    user_service: UserService,
    post_service: PostService,
    auth_service: AuthService,
}

impl GraphQLSchemaProvider {
    pub fn schema(&self) -> Schema<QueryRoot, MutationRoot, SubscriptionRoot> {
        Schema::build(QueryRoot, MutationRoot, SubscriptionRoot)
            .data(self.user_service.clone())
            .data(self.post_service.clone())
            .data(self.auth_service.clone())
            .limit_depth(10)
            .limit_complexity(1000)
            .finish()
    }
}

#[controller("/graphql")]
pub struct GraphQLController {
    schema_provider: GraphQLSchemaProvider,
}

impl GraphQLController {
    #[post("/")]
    async fn execute(
        &self,
        req: HttpRequest,
        body: Json<GraphQLRequest>,
    ) -> Result<Json<GraphQLResponse>, Error> {
        // Extract auth from request
        let auth = extract_auth(&req);

        let mut request = body.0.into_inner();
        if let Some(auth) = auth {
            request = request.data(auth);
        }

        let schema = self.schema_provider.schema();
        let response = schema.execute(request).await;

        Ok(Json(response.into()))
    }

    #[get("/")]
    async fn playground(&self) -> HttpResponse {
        HttpResponse::ok()
            .with_header("Content-Type", "text/html")
            .with_body(playground_source(
                GraphQLPlaygroundConfig::new("/graphql")
                    .subscription_endpoint("/graphql/ws")
            ))
    }

    #[get("/ws")]
    async fn subscriptions(
        &self,
        ws: WebSocketUpgrade,
    ) -> WebSocketResponse {
        let schema = self.schema_provider.schema();
        ws.on_upgrade(move |socket| async move {
            GraphQLSubscription::new(schema)
                .serve(socket)
                .await
        })
    }
}
```

## Error Handling

```rust
use async_graphql::*;

/// Custom error type for GraphQL.
#[derive(Debug, thiserror::Error)]
pub enum GraphQLError {
    #[error("Not found: {0}")]
    NotFound(String),

    #[error("Validation error: {0}")]
    Validation(String),

    #[error("Unauthorized")]
    Unauthorized,

    #[error("Forbidden")]
    Forbidden,

    #[error("Internal error")]
    Internal(#[from] anyhow::Error),
}

impl ErrorExtensions for GraphQLError {
    fn extend(&self) -> Error {
        let (code, message) = match self {
            Self::NotFound(msg) => ("NOT_FOUND", msg.as_str()),
            Self::Validation(msg) => ("VALIDATION_ERROR", msg.as_str()),
            Self::Unauthorized => ("UNAUTHORIZED", "Authentication required"),
            Self::Forbidden => ("FORBIDDEN", "Insufficient permissions"),
            Self::Internal(_) => ("INTERNAL_ERROR", "An internal error occurred"),
        };

        Error::new(message).extend_with(|_, e| {
            e.set("code", code);
        })
    }
}

// Usage
async fn get_user(&self, ctx: &Context<'_>, id: ID) -> Result<User> {
    let service = ctx.data::<UserService>()?;
    service.find_by_id(id.parse()?)
        .await?
        .ok_or_else(|| GraphQLError::NotFound(format!("User {} not found", id)).extend())
}
```

## Best Practices

1. **Use DataLoaders** to prevent N+1 queries
2. **Limit query depth** and complexity
3. **Use guards** for authorization
4. **Validate inputs** with built-in validators
5. **Document everything** with `///` comments
6. **Use connections** for pagination
7. **Handle errors** with proper codes
8. **Use subscriptions** for real-time updates
9. **Separate concerns** - types, resolvers, services
10. **Test queries** thoroughly

## Summary

```graphql
# Example query
query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    email
    posts {
      id
      title
    }
  }
}

# Example mutation
mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
    email
  }
}

# Example subscription
subscription OnMessage($roomId: ID!) {
  messages(roomId: $roomId) {
    id
    content
    sender {
      name
    }
  }
}
```
