---
description: Guidelines for background job processing with armature-queue
globs: armature-queue/**/*.rs, "**/jobs/**/*.rs, **/workers/**/*.rs"
alwaysApply: false
---

# Queue & Background Jobs

Standards for background job processing in Armature.

## Job Definition

```rust
use armature_queue::{Job, JobContext, JobResult};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct SendEmailJob {
    pub to: String,
    pub subject: String,
    pub body: String,
}

impl Job for SendEmailJob {
    const NAME: &'static str = "send_email";
    const QUEUE: &'static str = "emails";
    const MAX_RETRIES: u32 = 3;
    const TIMEOUT: Duration = Duration::from_secs(30);

    async fn perform(&self, ctx: &JobContext) -> JobResult {
        let mailer = ctx.resolve::<Mailer>()?;

        mailer.send(&self.to, &self.subject, &self.body).await?;

        Ok(())
    }
}
```

## Enqueueing Jobs

```rust
// Immediate execution
queue.enqueue(SendEmailJob {
    to: "user@example.com".into(),
    subject: "Welcome!".into(),
    body: "Hello, welcome to our app.".into(),
}).await?;

// Delayed execution
queue.enqueue_at(
    SendEmailJob { /* ... */ },
    Utc::now() + Duration::hours(1),
).await?;

// With priority
queue.enqueue_with_priority(
    SendEmailJob { /* ... */ },
    Priority::High,
).await?;
```

## Worker Configuration

```rust
let worker = Worker::new(queue)
    .concurrency(4)
    .queues(&["critical", "default", "low"])
    .register::<SendEmailJob>()
    .register::<ProcessImageJob>()
    .register::<GenerateReportJob>();

// Start processing
worker.run().await?;
```

## Retry Strategy

```rust
impl Job for SendEmailJob {
    fn retry_delay(&self, attempt: u32) -> Duration {
        // Exponential backoff: 10s, 60s, 360s, ...
        Duration::from_secs(10 * 6u64.pow(attempt - 1))
    }

    fn should_retry(&self, error: &JobError) -> bool {
        // Don't retry permanent failures
        !matches!(error, JobError::InvalidEmail(_))
    }
}
```

## Error Handling

```rust
#[derive(Error, Debug)]
pub enum JobError {
    #[error("Temporary failure: {0}")]
    Temporary(String), // Will retry

    #[error("Permanent failure: {0}")]
    Permanent(String), // Won't retry
}

async fn perform(&self, ctx: &JobContext) -> JobResult {
    match send_email(&self.to).await {
        Ok(()) => Ok(()),
        Err(e) if e.is_transient() => Err(JobError::Temporary(e.to_string()).into()),
        Err(e) => Err(JobError::Permanent(e.to_string()).into()),
    }
}
```

## Job Lifecycle Hooks

```rust
impl Job for ProcessImageJob {
    async fn before_perform(&self, ctx: &JobContext) -> Result<(), JobError> {
        tracing::info!(job_id = %ctx.job_id, "Starting image processing");
        Ok(())
    }

    async fn after_perform(&self, ctx: &JobContext, result: &JobResult) {
        match result {
            Ok(()) => tracing::info!(job_id = %ctx.job_id, "Image processed"),
            Err(e) => tracing::error!(job_id = %ctx.job_id, error = %e, "Processing failed"),
        }
    }

    async fn on_failure(&self, ctx: &JobContext, error: &JobError) {
        // Send alert, update status, etc.
        alert_team(format!("Job {} failed: {}", ctx.job_id, error)).await;
    }
}
```

## Batch Jobs

```rust
// Enqueue multiple jobs atomically
queue.enqueue_batch(vec![
    SendEmailJob { to: "user1@example.com".into(), /* ... */ },
    SendEmailJob { to: "user2@example.com".into(), /* ... */ },
    SendEmailJob { to: "user3@example.com".into(), /* ... */ },
]).await?;
```

## Scheduled Jobs (Cron)

```rust
use armature_cron::Schedule;

scheduler
    .add("cleanup_expired_sessions", "0 0 * * *", || async {
        cleanup_sessions().await
    })
    .add("generate_daily_report", "0 8 * * *", || async {
        generate_report().await
    })
    .start()
    .await?;
```

## Monitoring

```rust
// Get queue statistics
let stats = queue.stats().await?;
println!("Pending: {}", stats.pending);
println!("Processing: {}", stats.processing);
println!("Failed: {}", stats.failed);
println!("Completed: {}", stats.completed);

// Dead letter queue
let dead_jobs = queue.dead_letter_queue().list(100).await?;
for job in dead_jobs {
    // Inspect or retry
    queue.retry_dead_job(job.id).await?;
}
```

## Testing Jobs

```rust
#[tokio::test]
async fn test_send_email_job() {
    let mock_mailer = MockMailer::new();
    mock_mailer.expect_send().times(1).returning(|_, _, _| Ok(()));

    let ctx = JobContext::test()
        .with_service::<dyn Mailer>(Arc::new(mock_mailer));

    let job = SendEmailJob {
        to: "test@example.com".into(),
        subject: "Test".into(),
        body: "Body".into(),
    };

    let result = job.perform(&ctx).await;
    assert!(result.is_ok());
}
```
