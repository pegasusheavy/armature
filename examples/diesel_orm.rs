//! Diesel ORM Integration Example
//!
//! Demonstrates how to integrate Diesel ORM with Armature's dependency
//! injection system and lifecycle hooks.
//!
//! Diesel is the most popular Rust ORM with excellent compile-time guarantees.

use armature_core::Provider;
use armature_core::lifecycle::{LifecycleManager, OnApplicationShutdown, OnModuleInit};
use async_trait::async_trait;
use diesel::prelude::*;
use diesel::r2d2::{ConnectionManager, Pool, PooledConnection};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

// ============================================================================
// Diesel Schema and Models
// ============================================================================

// In a real app, this would be in schema.rs generated by diesel CLI
mod schema {
    diesel::table! {
        users (id) {
            id -> Int4,
            username -> Varchar,
            email -> Varchar,
            created_at -> Timestamp,
        }
    }
}

use schema::users;

// Domain models
#[derive(Debug, Clone, Serialize, Queryable, Selectable)]
#[diesel(table_name = users)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub email: String,
    pub created_at: chrono::NaiveDateTime,
}

#[derive(Debug, Insertable)]
#[diesel(table_name = users)]
pub struct NewUser {
    pub username: String,
    pub email: String,
}

// API models
#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub username: String,
    pub email: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdateUserRequest {
    pub username: Option<String>,
    pub email: Option<String>,
}

// ============================================================================
// Database Service with Diesel + Lifecycle Hooks
// ============================================================================

type PgPool = Pool<ConnectionManager<PgConnection>>;
type PgPooledConnection = PooledConnection<ConnectionManager<PgConnection>>;

/// Database service using Diesel ORM
///
/// This service:
/// - Initializes connection pool on module init
/// - Closes pool gracefully on shutdown
/// - Provides database operations using Diesel's type-safe query builder
#[derive(Clone)]
pub struct DieselDatabaseService {
    /// Connection string for the database
    connection_string: String,

    /// R2D2 connection pool (initialized after OnModuleInit)
    pool: Arc<RwLock<Option<PgPool>>>,
}

impl DieselDatabaseService {
    /// Create a new database service
    pub fn new(connection_string: String) -> Self {
        Self {
            connection_string,
            pool: Arc::new(RwLock::new(None)),
        }
    }

    /// Get a connection from the pool
    pub async fn get_connection(&self) -> Result<PgPooledConnection, diesel::result::Error> {
        let pool_guard = self.pool.read().await;
        let pool = pool_guard
            .as_ref()
            .ok_or_else(|| diesel::result::Error::NotFound)?;

        pool.get().map_err(|_| diesel::result::Error::NotFound)
    }

    /// Check if database is connected
    pub async fn is_connected(&self) -> bool {
        self.pool.read().await.is_some()
    }
}

// Mark as injectable provider
impl Provider for DieselDatabaseService {}

// Lifecycle hook: Initialize database connection on module init
#[async_trait]
impl OnModuleInit for DieselDatabaseService {
    async fn on_module_init(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("ðŸ“Š DieselDatabaseService: Connecting to PostgreSQL...");
        println!(
            "   Connection: {}",
            mask_connection_string(&self.connection_string)
        );

        // Create connection pool with R2D2
        let manager = ConnectionManager::<PgConnection>::new(&self.connection_string);
        let pool = Pool::builder()
            .max_size(5)
            .min_idle(Some(1))
            .connection_timeout(std::time::Duration::from_secs(5))
            .build(manager)?;

        // Test the connection
        let mut conn = pool.get()?;
        diesel::sql_query("SELECT 1").execute(&mut conn)?;

        // Store the pool
        *self.pool.write().await = Some(pool);

        println!("   âœ… Database connected successfully!");
        println!("   ðŸ“‹ Running migrations...");

        // Run migrations
        if let Some(pool) = self.pool.read().await.as_ref() {
            let mut conn = pool.get()?;
            self.run_migrations(&mut conn)?;
            println!("   âœ… Migrations complete!");
        }

        Ok(())
    }
}

// Lifecycle hook: Close database connection on shutdown
#[async_trait]
impl OnApplicationShutdown for DieselDatabaseService {
    async fn on_application_shutdown(
        &self,
        signal: Option<String>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        if let Some(sig) = signal {
            println!(
                "ðŸ“Š DieselDatabaseService: Closing connections (signal: {})...",
                sig
            );
        } else {
            println!("ðŸ“Š DieselDatabaseService: Closing connections...");
        }

        // R2D2 pool closes automatically when dropped
        self.pool.write().await.take();

        println!("   âœ… Database connections closed!");

        Ok(())
    }
}

// Database operations using Diesel's query builder
impl DieselDatabaseService {
    /// Run migrations (create tables)
    fn run_migrations(&self, conn: &mut PgConnection) -> Result<(), diesel::result::Error> {
        diesel::sql_query(
            r#"
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                username VARCHAR(255) NOT NULL UNIQUE,
                email VARCHAR(255) NOT NULL UNIQUE,
                created_at TIMESTAMP NOT NULL DEFAULT NOW()
            )
            "#,
        )
        .execute(conn)?;

        Ok(())
    }

    /// Get all users using Diesel's query builder
    pub async fn get_all_users(&self) -> Result<Vec<User>, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        // Diesel's type-safe query builder
        users::table
            .select(User::as_select())
            .order(users::id)
            .load(&mut conn)
    }

    /// Get user by ID
    pub async fn get_user_by_id(
        &self,
        user_id: i32,
    ) -> Result<Option<User>, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        users::table
            .find(user_id)
            .select(User::as_select())
            .first(&mut conn)
            .optional()
    }

    /// Create a new user
    pub async fn create_user(
        &self,
        username: String,
        email: String,
    ) -> Result<User, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        let new_user = NewUser { username, email };

        diesel::insert_into(users::table)
            .values(&new_user)
            .returning(User::as_returning())
            .get_result(&mut conn)
    }

    /// Update a user
    pub async fn update_user(
        &self,
        user_id: i32,
        username: Option<String>,
        email: Option<String>,
    ) -> Result<Option<User>, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        // Build dynamic update
        if username.is_some() || email.is_some() {
            let target = users::table.find(user_id);

            let result = if let Some(uname) = username {
                if let Some(mail) = email {
                    diesel::update(target)
                        .set((users::username.eq(uname), users::email.eq(mail)))
                        .returning(User::as_returning())
                        .get_result(&mut conn)
                        .optional()?
                } else {
                    diesel::update(target)
                        .set(users::username.eq(uname))
                        .returning(User::as_returning())
                        .get_result(&mut conn)
                        .optional()?
                }
            } else if let Some(mail) = email {
                diesel::update(target)
                    .set(users::email.eq(mail))
                    .returning(User::as_returning())
                    .get_result(&mut conn)
                    .optional()?
            } else {
                None
            };

            Ok(result)
        } else {
            self.get_user_by_id(user_id).await
        }
    }

    /// Delete a user
    pub async fn delete_user(&self, user_id: i32) -> Result<bool, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        let count = diesel::delete(users::table.find(user_id)).execute(&mut conn)?;

        Ok(count > 0)
    }

    /// Get user count
    pub async fn count_users(&self) -> Result<i64, diesel::result::Error> {
        let mut conn = self.get_connection().await?;

        users::table.count().get_result(&mut conn)
    }
}

// ============================================================================
// User Service (Business Logic Layer)
// ============================================================================

#[derive(Clone)]
pub struct UserService {
    db: Arc<DieselDatabaseService>,
}

impl UserService {
    pub fn new(db: DieselDatabaseService) -> Self {
        Self { db: Arc::new(db) }
    }

    pub async fn list_users(&self) -> Result<Vec<User>, String> {
        self.db
            .get_all_users()
            .await
            .map_err(|e| format!("Failed to fetch users: {}", e))
    }

    pub async fn get_user(&self, id: i32) -> Result<Option<User>, String> {
        self.db
            .get_user_by_id(id)
            .await
            .map_err(|e| format!("Failed to fetch user: {}", e))
    }

    pub async fn create_user(&self, req: CreateUserRequest) -> Result<User, String> {
        // Validation
        if req.username.is_empty() {
            return Err("Username cannot be empty".to_string());
        }

        if !req.email.contains('@') {
            return Err("Invalid email address".to_string());
        }

        self.db
            .create_user(req.username, req.email)
            .await
            .map_err(|e| format!("Failed to create user: {}", e))
    }

    pub async fn update_user(
        &self,
        id: i32,
        req: UpdateUserRequest,
    ) -> Result<Option<User>, String> {
        self.db
            .update_user(id, req.username, req.email)
            .await
            .map_err(|e| format!("Failed to update user: {}", e))
    }

    pub async fn delete_user(&self, id: i32) -> Result<bool, String> {
        self.db
            .delete_user(id)
            .await
            .map_err(|e| format!("Failed to delete user: {}", e))
    }

    pub async fn stats(&self) -> Result<serde_json::Value, String> {
        let count = self
            .db
            .count_users()
            .await
            .map_err(|e| format!("Failed to get stats: {}", e))?;

        Ok(serde_json::json!({
            "total_users": count,
            "database": "PostgreSQL (Diesel ORM)",
            "connected": self.db.is_connected().await
        }))
    }
}

impl Provider for UserService {}

// ============================================================================
// Main Example
// ============================================================================

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘         Diesel ORM Integration Example                     â•‘");
    println!("â•‘       Armature DI + Lifecycle Hooks + Diesel               â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // Get database URL from environment
    let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| {
        println!("âš ï¸  DATABASE_URL not set, using default (demo mode)");
        "postgres://postgres:password@localhost/armature_diesel".to_string()
    });

    println!("ðŸ“‹ Configuration:");
    println!("   Database: {}\n", mask_connection_string(&database_url));

    // Create lifecycle manager
    let lifecycle = LifecycleManager::new();

    // Create database service
    let db_service = Arc::new(DieselDatabaseService::new(database_url.clone()));

    // Register lifecycle hooks
    println!("ðŸ”§ Registering lifecycle hooks...");
    lifecycle
        .register_on_init("DieselDatabaseService".to_string(), db_service.clone())
        .await;
    lifecycle
        .register_on_shutdown("DieselDatabaseService".to_string(), db_service.clone())
        .await;
    println!("   âœ… Hooks registered\n");

    // Initialize database
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  INITIALIZATION PHASE                         ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    if let Err(errors) = lifecycle.call_module_init_hooks().await {
        eprintln!("\nâŒ Failed to initialize database:");
        for (name, error) in errors {
            eprintln!("   {} - {}", name, error);
        }
        eprintln!("\nðŸ’¡ Make sure PostgreSQL is running:");
        eprintln!("   docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=password postgres");
        eprintln!("   export DATABASE_URL=postgres://postgres:password@localhost/armature_diesel");
        return Ok(());
    }

    println!();

    // Create services with dependency injection
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  DEPENDENCY INJECTION                         ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸ”Œ Injecting DieselDatabaseService into UserService...");
    let user_service = Arc::new(UserService::new((*db_service).clone()));
    println!("   âœ… UserService created\n");

    // Demonstrate CRUD operations
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  DIESEL ORM OPERATIONS                        ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸ“ Creating test users using Diesel's type-safe query builder...");
    match user_service
        .create_user(CreateUserRequest {
            username: "alice_diesel".to_string(),
            email: "alice@diesel.example.com".to_string(),
        })
        .await
    {
        Ok(user) => println!("   âœ… Created user: {} (ID: {})", user.username, user.id),
        Err(e) => println!("   âš ï¸  {}", e),
    }

    match user_service
        .create_user(CreateUserRequest {
            username: "bob_diesel".to_string(),
            email: "bob@diesel.example.com".to_string(),
        })
        .await
    {
        Ok(user) => println!("   âœ… Created user: {} (ID: {})", user.username, user.id),
        Err(e) => println!("   âš ï¸  {}", e),
    }

    println!();

    // List users
    println!("ðŸ“‹ Listing all users with Diesel query...");
    match user_service.list_users().await {
        Ok(users) => {
            println!("   Found {} users:", users.len());
            for user in users {
                println!("   - {} <{}> (ID: {})", user.username, user.email, user.id);
            }
        }
        Err(e) => println!("   âŒ Error: {}", e),
    }

    println!();

    // Get stats
    println!("ðŸ“Š Database statistics...");
    match user_service.stats().await {
        Ok(stats) => println!("   {}", serde_json::to_string_pretty(&stats).unwrap()),
        Err(e) => println!("   âŒ Error: {}", e),
    }

    println!();

    // Graceful shutdown
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  GRACEFUL SHUTDOWN                            ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    lifecycle
        .call_shutdown_hooks(Some("SIGTERM".to_string()))
        .await
        .ok();

    println!("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ… Diesel ORM integration example complete!");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸŽ¯ Key Features Demonstrated:");
    println!("   âœ… Diesel's type-safe query builder");
    println!("   âœ… R2D2 connection pooling");
    println!("   âœ… Lifecycle hook integration");
    println!("   âœ… Dependency injection");
    println!("   âœ… Compile-time SQL verification");
    println!();

    Ok(())
}

// Helper function
fn mask_connection_string(conn_str: &str) -> String {
    if let Some(at_pos) = conn_str.find('@') {
        if let Some(colon_pos) = conn_str[..at_pos].rfind(':') {
            let mut masked = conn_str.to_string();
            masked.replace_range(colon_pos + 1..at_pos, "****");
            return masked;
        }
    }
    conn_str.to_string()
}
