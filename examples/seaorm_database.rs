//! SeaORM Integration Example
//!
//! Demonstrates how to integrate SeaORM with Armature's dependency
//! injection system and lifecycle hooks.
//!
//! SeaORM is a modern, async-first ORM for Rust with excellent ergonomics.

use armature_core::lifecycle::{LifecycleManager, OnApplicationShutdown, OnModuleInit};
use armature_core::Provider;
use async_trait::async_trait;
use sea_orm::*;
use serde::Deserialize;
use std::sync::Arc;
use tokio::sync::RwLock;

// ============================================================================
// SeaORM Entity Definitions
// ============================================================================

// In a real app, these would be generated by sea-orm-cli
pub mod entities {
    use sea_orm::entity::prelude::*;
    use serde::{Deserialize, Serialize};

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
    #[sea_orm(table_name = "users")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub username: String,
        pub email: String,
        pub created_at: DateTimeUtc,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

use entities::{ActiveModel, Column, Entity as UserEntity, Model as User};

// API models
#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub username: String,
    pub email: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdateUserRequest {
    pub username: Option<String>,
    pub email: Option<String>,
}

// ============================================================================
// Database Service with SeaORM + Lifecycle Hooks
// ============================================================================

/// Database service using SeaORM
///
/// This service:
/// - Initializes async database connection on module init
/// - Closes connection gracefully on shutdown
/// - Provides database operations using SeaORM's async API
#[derive(Clone)]
pub struct SeaOrmDatabaseService {
    /// Connection string for the database
    connection_string: String,
    
    /// SeaORM database connection (initialized after OnModuleInit)
    db: Arc<RwLock<Option<DatabaseConnection>>>,
}

impl SeaOrmDatabaseService {
    /// Create a new database service
    pub fn new(connection_string: String) -> Self {
        Self {
            connection_string,
            db: Arc::new(RwLock::new(None)),
        }
    }

    /// Get a reference to the database connection
    pub async fn connection(&self) -> Result<DatabaseConnection, DbErr> {
        let db_guard = self.db.read().await;
        db_guard
            .clone()
            .ok_or_else(|| DbErr::Custom("Database not initialized".to_string()))
    }

    /// Check if database is connected
    pub async fn is_connected(&self) -> bool {
        self.db.read().await.is_some()
    }
}

// Mark as injectable provider
impl Provider for SeaOrmDatabaseService {}

// Lifecycle hook: Initialize database connection on module init
#[async_trait]
impl OnModuleInit for SeaOrmDatabaseService {
    async fn on_module_init(
        &self,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("ðŸ“Š SeaOrmDatabaseService: Connecting to PostgreSQL...");
        println!("   Connection: {}", mask_connection_string(&self.connection_string));

        // Create SeaORM database connection with connection options
        let mut opt = ConnectOptions::new(&self.connection_string);
        opt
            .max_connections(5)
            .min_connections(1)
            .connect_timeout(std::time::Duration::from_secs(5))
            .idle_timeout(std::time::Duration::from_secs(600))
            .sqlx_logging(false); // Disable SQLx logging for cleaner output

        let db = Database::connect(opt).await?;

        // Test the connection
        db.execute(Statement::from_string(
            DatabaseBackend::Postgres,
            "SELECT 1".to_string(),
        ))
        .await?;

        // Store the connection
        *self.db.write().await = Some(db);

        println!("   âœ… Database connected successfully!");
        println!("   ðŸ“‹ Running migrations...");

        // Run migrations
        if let Some(db) = self.db.read().await.as_ref() {
            self.run_migrations(db).await?;
            println!("   âœ… Migrations complete!");
        }

        Ok(())
    }
}

// Lifecycle hook: Close database connection on shutdown
#[async_trait]
impl OnApplicationShutdown for SeaOrmDatabaseService {
    async fn on_application_shutdown(
        &self,
        signal: Option<String>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        if let Some(sig) = signal {
            println!("ðŸ“Š SeaOrmDatabaseService: Closing connections (signal: {})...", sig);
        } else {
            println!("ðŸ“Š SeaOrmDatabaseService: Closing connections...");
        }

        // Close the connection
        if let Some(db) = self.db.write().await.take() {
            db.close().await?;
            println!("   âœ… Database connections closed!");
        }

        Ok(())
    }
}

// Database operations using SeaORM's async API
impl SeaOrmDatabaseService {
    /// Run migrations (create tables)
    async fn run_migrations(&self, db: &DatabaseConnection) -> Result<(), DbErr> {
        let sql = r#"
            CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                username VARCHAR(255) NOT NULL UNIQUE,
                email VARCHAR(255) NOT NULL UNIQUE,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            )
        "#;

        db.execute(Statement::from_string(DatabaseBackend::Postgres, sql.to_string()))
            .await?;

        Ok(())
    }

    /// Get all users using SeaORM's query builder
    pub async fn get_all_users(&self) -> Result<Vec<User>, DbErr> {
        let db = self.connection().await?;

        UserEntity::find()
            .order_by_asc(Column::Id)
            .all(&db)
            .await
    }

    /// Get user by ID
    pub async fn get_user_by_id(&self, user_id: i32) -> Result<Option<User>, DbErr> {
        let db = self.connection().await?;

        UserEntity::find_by_id(user_id)
            .one(&db)
            .await
    }

    /// Create a new user
    pub async fn create_user(
        &self,
        username: String,
        email: String,
    ) -> Result<User, DbErr> {
        let db = self.connection().await?;

        let user = ActiveModel {
            username: Set(username),
            email: Set(email),
            created_at: Set(chrono::Utc::now()),
            ..Default::default()
        };

        user.insert(&db).await
    }

    /// Update a user
    pub async fn update_user(
        &self,
        user_id: i32,
        username: Option<String>,
        email: Option<String>,
    ) -> Result<Option<User>, DbErr> {
        let db = self.connection().await?;

        // Find existing user
        let user = UserEntity::find_by_id(user_id)
            .one(&db)
            .await?;

        if let Some(user) = user {
            let mut active_user: ActiveModel = user.into();

            // Update only provided fields
            if let Some(uname) = username {
                active_user.username = Set(uname);
            }

            if let Some(mail) = email {
                active_user.email = Set(mail);
            }

            Ok(Some(active_user.update(&db).await?))
        } else {
            Ok(None)
        }
    }

    /// Delete a user
    pub async fn delete_user(&self, user_id: i32) -> Result<bool, DbErr> {
        let db = self.connection().await?;

        let result = UserEntity::delete_by_id(user_id)
            .exec(&db)
            .await?;

        Ok(result.rows_affected > 0)
    }

    /// Get user count
    pub async fn count_users(&self) -> Result<u64, DbErr> {
        let db = self.connection().await?;

        UserEntity::find()
            .count(&db)
            .await
    }

    /// Search users by username (demonstrates SeaORM query features)
    pub async fn search_users(&self, query: &str) -> Result<Vec<User>, DbErr> {
        let db = self.connection().await?;

        UserEntity::find()
            .filter(Column::Username.contains(query))
            .order_by_asc(Column::Username)
            .all(&db)
            .await
    }
}

// ============================================================================
// User Service (Business Logic Layer)
// ============================================================================

#[derive(Clone)]
pub struct UserService {
    db: Arc<SeaOrmDatabaseService>,
}

impl UserService {
    pub fn new(db: SeaOrmDatabaseService) -> Self {
        Self { db: Arc::new(db) }
    }

    pub async fn list_users(&self) -> Result<Vec<User>, String> {
        self.db
            .get_all_users()
            .await
            .map_err(|e| format!("Failed to fetch users: {}", e))
    }

    pub async fn get_user(&self, id: i32) -> Result<Option<User>, String> {
        self.db
            .get_user_by_id(id)
            .await
            .map_err(|e| format!("Failed to fetch user: {}", e))
    }

    pub async fn create_user(&self, req: CreateUserRequest) -> Result<User, String> {
        // Validation
        if req.username.is_empty() {
            return Err("Username cannot be empty".to_string());
        }

        if !req.email.contains('@') {
            return Err("Invalid email address".to_string());
        }

        self.db
            .create_user(req.username, req.email)
            .await
            .map_err(|e| format!("Failed to create user: {}", e))
    }

    pub async fn update_user(&self, id: i32, req: UpdateUserRequest) -> Result<Option<User>, String> {
        self.db
            .update_user(id, req.username, req.email)
            .await
            .map_err(|e| format!("Failed to update user: {}", e))
    }

    pub async fn delete_user(&self, id: i32) -> Result<bool, String> {
        self.db
            .delete_user(id)
            .await
            .map_err(|e| format!("Failed to delete user: {}", e))
    }

    pub async fn search_users(&self, query: &str) -> Result<Vec<User>, String> {
        self.db
            .search_users(query)
            .await
            .map_err(|e| format!("Failed to search users: {}", e))
    }

    pub async fn stats(&self) -> Result<serde_json::Value, String> {
        let count = self.db
            .count_users()
            .await
            .map_err(|e| format!("Failed to get stats: {}", e))?;

        Ok(serde_json::json!({
            "total_users": count,
            "database": "PostgreSQL (SeaORM)",
            "connected": self.db.is_connected().await,
            "orm": "async"
        }))
    }
}

impl Provider for UserService {}

// ============================================================================
// Main Example
// ============================================================================

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘         SeaORM Integration Example                         â•‘");
    println!("â•‘       Armature DI + Lifecycle Hooks + SeaORM               â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // Get database URL from environment
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| {
            println!("âš ï¸  DATABASE_URL not set, using default (demo mode)");
            "postgres://postgres:password@localhost/armature_seaorm".to_string()
        });

    println!("ðŸ“‹ Configuration:");
    println!("   Database: {}\n", mask_connection_string(&database_url));

    // Create lifecycle manager
    let lifecycle = LifecycleManager::new();

    // Create database service
    let db_service = Arc::new(SeaOrmDatabaseService::new(database_url.clone()));

    // Register lifecycle hooks
    println!("ðŸ”§ Registering lifecycle hooks...");
    lifecycle
        .register_on_init("SeaOrmDatabaseService".to_string(), db_service.clone())
        .await;
    lifecycle
        .register_on_shutdown("SeaOrmDatabaseService".to_string(), db_service.clone())
        .await;
    println!("   âœ… Hooks registered\n");

    // Initialize database
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  INITIALIZATION PHASE                         ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    if let Err(errors) = lifecycle.call_module_init_hooks().await {
        eprintln!("\nâŒ Failed to initialize database:");
        for (name, error) in errors {
            eprintln!("   {} - {}", name, error);
        }
        eprintln!("\nðŸ’¡ Make sure PostgreSQL is running:");
        eprintln!("   docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=password postgres");
        eprintln!("   export DATABASE_URL=postgres://postgres:password@localhost/armature_seaorm");
        return Ok(());
    }

    println!();

    // Create services with dependency injection
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  DEPENDENCY INJECTION                         ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸ”Œ Injecting SeaOrmDatabaseService into UserService...");
    let user_service = Arc::new(UserService::new((*db_service).clone()));
    println!("   âœ… UserService created\n");

    // Demonstrate CRUD operations
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  SEAORM ASYNC OPERATIONS                      ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸ“ Creating test users using SeaORM's async API...");
    match user_service
        .create_user(CreateUserRequest {
            username: "alice_sea".to_string(),
            email: "alice@seaorm.example.com".to_string(),
        })
        .await
    {
        Ok(user) => println!("   âœ… Created user: {} (ID: {})", user.username, user.id),
        Err(e) => println!("   âš ï¸  {}", e),
    }

    match user_service
        .create_user(CreateUserRequest {
            username: "bob_sea".to_string(),
            email: "bob@seaorm.example.com".to_string(),
        })
        .await
    {
        Ok(user) => println!("   âœ… Created user: {} (ID: {})", user.username, user.id),
        Err(e) => println!("   âš ï¸  {}", e),
    }

    println!();

    // List users
    println!("ðŸ“‹ Listing all users with SeaORM async query...");
    match user_service.list_users().await {
        Ok(users) => {
            println!("   Found {} users:", users.len());
            for user in users {
                println!("   - {} <{}> (ID: {})", user.username, user.email, user.id);
            }
        }
        Err(e) => println!("   âŒ Error: {}", e),
    }

    println!();

    // Search feature
    println!("ðŸ” Searching users with 'sea' in username...");
    match user_service.search_users("sea").await {
        Ok(users) => {
            println!("   Found {} matching users:", users.len());
            for user in users {
                println!("   - {} <{}>", user.username, user.email);
            }
        }
        Err(e) => println!("   âŒ Error: {}", e),
    }

    println!();

    // Get stats
    println!("ðŸ“Š Database statistics...");
    match user_service.stats().await {
        Ok(stats) => println!("   {}", serde_json::to_string_pretty(&stats).unwrap()),
        Err(e) => println!("   âŒ Error: {}", e),
    }

    println!();

    // Graceful shutdown
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("                  GRACEFUL SHUTDOWN                            ");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    lifecycle
        .call_shutdown_hooks(Some("SIGTERM".to_string()))
        .await
        .ok();

    println!("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ… SeaORM integration example complete!");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    println!("ðŸŽ¯ Key Features Demonstrated:");
    println!("   âœ… SeaORM's async-first API");
    println!("   âœ… Modern Rust patterns");
    println!("   âœ… Entity-based models");
    println!("   âœ… ActiveModel pattern");
    println!("   âœ… Advanced query features");
    println!();

    Ok(())
}

// Helper function
fn mask_connection_string(conn_str: &str) -> String {
    if let Some(at_pos) = conn_str.find('@') {
        if let Some(colon_pos) = conn_str[..at_pos].rfind(':') {
            let mut masked = conn_str.to_string();
            masked.replace_range(colon_pos + 1..at_pos, "****");
            return masked;
        }
    }
    conn_str.to_string()
}

